{"version":3,"file":"L.Control.Locate.min.js","sources":["../src/L.Control.Locate.js"],"sourcesContent":["/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\n\nimport { Control, Marker, DomUtil, setOptions, divIcon, LayerGroup, Circle, DomEvent, Util as LeafletUtil } from \"leaflet\";\n\nconst METERS_TO_FEET = 3.2808399;\n\n/**\n * Add one or more CSS classes to an element.\n * @param {HTMLElement} el - The element to add classes to.\n * @param {string} names - Space-separated class names.\n */\nfunction addClasses(el, names) {\n  names.split(\" \").forEach((className) => {\n    el.classList.add(className);\n  });\n}\n\n/**\n * Remove one or more CSS classes from an element.\n * @param {HTMLElement} el - The element to remove classes from.\n * @param {string} names - Space-separated class names.\n */\nfunction removeClasses(el, names) {\n  names.split(\" \").forEach((className) => {\n    el.classList.remove(className);\n  });\n}\n\n/**\n * Shallow clone options to prevent prototype pollution.\n * Clones arrays and plain objects, keeps functions/classes as references.\n * @param {Object} options - The options object to clone.\n * @returns {Object} A shallow clone of the options object.\n */\nfunction cloneOptions(options) {\n  const cloned = {};\n  for (const key in options) {\n    const val = options[key];\n    if (Array.isArray(val)) {\n      cloned[key] = [...val];\n    } else if (val?.constructor === Object) {\n      cloned[key] = { ...val };\n    } else {\n      cloned[key] = val;\n    }\n  }\n  return cloned;\n}\n\n/**\n * Compatible with Circle but a true marker instead of a path\n */\nconst LocationMarker = Marker.extend({\n  initialize(latlng, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this.createIcon();\n  },\n\n  /**\n   * Create a styled circle location marker\n   */\n  createIcon() {\n    const opt = this.options;\n\n    const style = [\n      [\"stroke\", opt.color],\n      [\"stroke-width\", opt.weight],\n      [\"fill\", opt.fillColor],\n      [\"fill-opacity\", opt.fillOpacity],\n      [\"opacity\", opt.opacity]\n    ]\n      .filter(([, v]) => v !== undefined)\n      .map(([k, v]) => `${k}=\"${v}\"`)\n      .join(\" \");\n\n    const icon = this._getIconSVG(opt, style);\n\n    this._locationIcon = divIcon({\n      className: icon.className,\n      html: icon.svg,\n      iconSize: [icon.w, icon.h]\n    });\n\n    this.setIcon(this._locationIcon);\n  },\n\n  /**\n   * Return the raw svg for the shape\n   *\n   * Split so can be easily overridden\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const w = options.weight;\n    const s = r + w;\n    const s2 = s * 2;\n    const svg =\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${s2}\" height=\"${s2}\" version=\"1.1\" viewBox=\"-${s} -${s} ${s2} ${s2}\">` +\n      `<circle r=\"${r}\" ${style} /></svg>`;\n    return {\n      className: \"leaflet-control-locate-location\",\n      svg,\n      w: s2,\n      h: s2\n    };\n  },\n\n  setStyle(style) {\n    setOptions(this, style);\n    this.createIcon();\n  }\n});\n\nconst CompassMarker = LocationMarker.extend({\n  initialize(latlng, heading, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this._heading = heading;\n    this.createIcon();\n  },\n\n  setHeading(heading) {\n    this._heading = heading;\n  },\n\n  /**\n   * Create a styled arrow compass marker\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const s = r + options.weight + options.depth;\n    const s2 = s * 2;\n\n    const path = this._arrowPoints(r, options.width, options.depth, this._heading);\n\n    const svg =\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${s2}\" height=\"${s2}\" version=\"1.1\" viewBox=\"-${s} -${s} ${s2} ${s2}\">` +\n      `<path d=\"${path}\" ${style} /></svg>`;\n    return {\n      className: \"leaflet-control-locate-heading\",\n      svg,\n      w: s2,\n      h: s2\n    };\n  },\n\n  _arrowPoints(radius, width, depth, heading) {\n    const φ = ((heading - 90) * Math.PI) / 180;\n    const ux = Math.cos(φ);\n    const uy = Math.sin(φ);\n    const vx = -Math.sin(φ);\n    const vy = Math.cos(φ);\n    const h = width / 2;\n\n    // Base center on circle\n    const Cx = radius * ux;\n    const Cy = radius * uy;\n\n    // Base corners\n    const B1x = Cx + h * vx;\n    const B1y = Cy + h * vy;\n    const B2x = Cx - h * vx;\n    const B2y = Cy - h * vy;\n\n    // Tip outward\n    const Tx = Cx + depth * ux;\n    const Ty = Cy + depth * uy;\n\n    return `M ${B1x},${B1y} L ${B2x},${B2y} L ${Tx},${Ty} Z`;\n  }\n});\n\nconst LocateControl = Control.extend({\n  options: {\n    /** Position of the control */\n    position: \"topleft\",\n    /** The layer that the user's location should be drawn on. By default creates a new layer. */\n    layer: undefined,\n    /**\n     * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n     * While the map is following the user's location, the control is in the `following` state,\n     * which changes the style of the control and the circle marker.\n     *\n     * Possible values:\n     *  - false: never updates the map view when location changes.\n     *  - 'once': set the view when the location is first determined\n     *  - 'always': always updates the map view when location changes.\n     *              The map view follows the user's location.\n     *  - 'untilPan': like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     *  - 'untilPanOrZoom': (default) like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     */\n    setView: \"untilPanOrZoom\",\n    /**\n     * Keep the current map zoom level when setting the view and only pan.\n     * Can be set to:\n     * - `true`: Always keep current zoom level\n     * - `false`: Allow zooming (default)\n     * - `[minZoom, maxZoom]`: Keep zoom only when current zoom is within the specified range\n     */\n    keepCurrentZoomLevel: false,\n    /** After activating the plugin by clicking on the icon, zoom to the selected zoom level, even when keepCurrentZoomLevel is true. Set to 'false' to disable this feature. */\n    initialZoomLevel: false,\n    /**\n     * This callback can be used to override the viewport tracking\n     * This function should return a LatLngBounds object.\n     *\n     * For example to extend the viewport to ensure that a particular LatLng is visible:\n     *\n     * getLocationBounds: function(locationEvent) {\n     *    return locationEvent.bounds.extend([-33.873085, 151.219273]);\n     * },\n     */\n    getLocationBounds(locationEvent) {\n      return locationEvent.bounds;\n    },\n    /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */\n    flyTo: false,\n    /**\n     * The user location can be inside and outside the current view when the user clicks on the\n     * control that is already active. Both cases can be configures separately.\n     * Possible values are:\n     *  - 'setView': zoom and pan to the current location\n     *  - 'stop': stop locating and remove the location marker\n     */\n    clickBehavior: {\n      /** What should happen if the user clicks on the control while the location is within the current view. */\n      inView: \"stop\",\n      /** What should happen if the user clicks on the control while the location is outside the current view. */\n      outOfView: \"setView\",\n      /**\n       * What should happen if the user clicks on the control while the location is within the current view\n       * and we could be following but are not. Defaults to a special value which inherits from 'inView';\n       */\n      inViewNotFollowing: \"inView\"\n    },\n    /**\n     * If set, save the map bounds just before centering to the user's\n     * location. When control is disabled, set the view back to the\n     * bounds that were saved.\n     */\n    returnToPrevBounds: false,\n    /**\n     * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait\n     * until the locate API returns a new location before they see where they are again.\n     */\n    cacheLocation: true,\n    /** If set, a circle that shows the location accuracy is drawn. */\n    drawCircle: true,\n    /** If set, the marker at the users' location is drawn. */\n    drawMarker: true,\n    /** If set and supported then show the compass heading */\n    showCompass: true,\n    /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n    markerClass: LocationMarker,\n    /** The class us be used to create the compass bearing arrow */\n    compassClass: CompassMarker,\n    /** Accuracy circle style properties. NOTE these styles should match the css animations styles */\n    circleStyle: {\n      className: \"leaflet-control-locate-circle\",\n      color: \"#136AEC\",\n      fillColor: \"#136AEC\",\n      fillOpacity: 0.15,\n      weight: 0\n    },\n    /** Inner marker style properties. Only works if your marker class supports `setStyle`. */\n    markerStyle: {\n      className: \"leaflet-control-locate-marker\",\n      color: \"#fff\",\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 3,\n      opacity: 1,\n      radius: 9\n    },\n    /** Compass */\n    compassStyle: {\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 0,\n      color: \"#fff\",\n      opacity: 1,\n      radius: 9, // How far is the arrow from the center of the marker\n      width: 9, // Width of the arrow\n      depth: 6 // Length of the arrow\n    },\n    /**\n     * Changes to accuracy circle and inner marker while following.\n     * It is only necessary to provide the properties that should change.\n     */\n    followCircleStyle: {},\n    followMarkerStyle: {\n      // color: '#FFA500',\n      // fillColor: '#FFB000'\n    },\n    followCompassStyle: {},\n    /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n    icon: \"leaflet-control-locate-location-arrow\",\n    iconLoading: \"leaflet-control-locate-spinner\",\n    /** The element to be created for icons. For example span or i */\n    iconElementTag: \"span\",\n    /** The element to be created for the text. For example small or span */\n    textElementTag: \"small\",\n    /** Padding around the accuracy circle. */\n    circlePadding: [0, 0],\n    /** Use metric units. */\n    metric: true,\n    /**\n     * This callback can be used in case you would like to override button creation behavior.\n     * This is useful for DOM manipulation frameworks such as angular etc.\n     * This function should return an object with HtmlElement for the button (link property) and the icon (icon property).\n     */\n    createButtonCallback(container, options) {\n      const link = DomUtil.create(\"a\", \"leaflet-bar-part leaflet-bar-part-single\", container);\n      link.title = options.strings.title;\n      link.href = \"#\";\n      link.setAttribute(\"role\", \"button\");\n      link.setAttribute(\"aria-label\", options.strings.title);\n      const icon = DomUtil.create(options.iconElementTag, options.icon, link);\n      // Add common class for all icons to enable color status changes\n      icon.classList.add(\"leaflet-locate-icon\");\n\n      if (options.strings.text !== undefined) {\n        const text = DomUtil.create(options.textElementTag, \"leaflet-locate-text\", link);\n        text.textContent = options.strings.text;\n        link.classList.add(\"leaflet-locate-text-active\");\n        link.parentNode.style.display = \"flex\";\n      }\n\n      return { link, icon };\n    },\n    /** This event is called in case of any location error that is not a time out error. */\n    onLocationError(err) {\n      alert(err.message);\n    },\n    /**\n     * This event is called when the user's location is outside the bounds set on the map.\n     * The event is called repeatedly when the location changes.\n     */\n    onLocationOutsideMapBounds(control) {\n      control.stop();\n      alert(control.options.strings.outsideMapBoundsMsg);\n    },\n    /** Display a pop-up when the user click on the inner marker. */\n    showPopup: true,\n    strings: {\n      title: \"Show me where I am\",\n      metersUnit: \"meters\",\n      feetUnit: \"feet\",\n      popup: \"You are within {distance} {unit} from this point\",\n      outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n    },\n    /** The default options passed to leaflets locate method. */\n    locateOptions: {\n      maxZoom: Infinity,\n      watch: true, // if you overwrite this, visualization cannot be updated\n      setView: false // have to set this to false because we have to\n      // do setView manually\n    }\n  },\n\n  initialize(options = {}) {\n    // Clone default options to prevent prototype pollution\n    this.options = cloneOptions(this.options);\n\n    // Merge user-provided options\n    for (const key in options) {\n      const userVal = options[key];\n      const defaultVal = this.options[key];\n      if (userVal?.constructor === Object && defaultVal?.constructor === Object) {\n        Object.assign(defaultVal, userVal);\n      } else {\n        this.options[key] = userVal;\n      }\n    }\n\n    // Follow styles inherit from base styles\n    Object.assign(this.options.followMarkerStyle, this.options.markerStyle, this.options.followMarkerStyle);\n    Object.assign(this.options.followCircleStyle, this.options.circleStyle, this.options.followCircleStyle);\n    Object.assign(this.options.followCompassStyle, this.options.compassStyle, this.options.followCompassStyle);\n  },\n\n  /**\n   * Add control to map. Returns the container for the control.\n   */\n  onAdd(map) {\n    const container = DomUtil.create(\"div\", \"leaflet-control-locate leaflet-bar leaflet-control\");\n    this._container = container;\n    this._map = map;\n    this._layer = this.options.layer || new LayerGroup();\n    this._layer.addTo(map);\n    this._event = undefined;\n    this._compassHeading = null;\n    this._prevBounds = null;\n\n    const linkAndIcon = this.options.createButtonCallback(container, this.options);\n    this._link = linkAndIcon.link;\n    this._icon = linkAndIcon.icon;\n\n    DomEvent.on(\n      this._link,\n      \"click\",\n      function (ev) {\n        DomEvent.stopPropagation(ev);\n        DomEvent.preventDefault(ev);\n        this._onClick();\n      },\n      this\n    ).on(this._link, \"dblclick\", DomEvent.stopPropagation);\n\n    this._resetVariables();\n\n    this._map.on(\"unload\", this._unload, this);\n\n    return container;\n  },\n\n  /**\n   * Called when control is removed from the map.\n   */\n  onRemove() {\n    this.stop();\n  },\n\n  /**\n   * This method is called when the user clicks on the control.\n   */\n  _onClick() {\n    this._justClicked = true;\n    const wasFollowing = this._isFollowing();\n    this._userPanned = false;\n    this._userZoomed = false;\n\n    if (this._active && !this._event) {\n      // click while requesting\n      this.stop();\n    } else if (this._active) {\n      const behaviors = this.options.clickBehavior;\n      let behavior = behaviors.outOfView;\n      if (this._map.getBounds().contains(this._event.latlng)) {\n        behavior = wasFollowing ? behaviors.inView : behaviors.inViewNotFollowing;\n      }\n\n      // Allow inheriting from another behavior\n      if (behaviors[behavior]) {\n        behavior = behaviors[behavior];\n      }\n\n      switch (behavior) {\n        case \"setView\":\n          this.setView();\n          break;\n        case \"stop\":\n          this.stop();\n          if (this.options.returnToPrevBounds) {\n            const f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n            f.bind(this._map)(this._prevBounds);\n          }\n          break;\n      }\n    } else {\n      if (this.options.returnToPrevBounds) {\n        this._prevBounds = this._map.getBounds();\n      }\n      this.start();\n    }\n\n    this._updateContainerStyle();\n  },\n\n  /**\n   * Starts the plugin:\n   * - activates the engine\n   * - draws the marker (if coordinates available)\n   */\n  start() {\n    this._activate();\n\n    if (this._event) {\n      this._drawMarker(this._map);\n\n      // if we already have a location but the user clicked on the control\n      if (this.options.setView) {\n        this.setView();\n      }\n    }\n    this._updateContainerStyle();\n  },\n\n  /**\n   * Stops the plugin:\n   * - deactivates the engine\n   * - reinitializes the button\n   * - removes the marker\n   */\n  stop() {\n    this._deactivate();\n\n    this._cleanClasses();\n    this._resetVariables();\n\n    this._removeMarker();\n  },\n\n  /**\n   * Keep the control active but stop following the location\n   */\n  stopFollowing() {\n    this._userPanned = true;\n    this._updateContainerStyle();\n    this._drawMarker();\n  },\n\n  /**\n   * This method launches the location engine.\n   * It is called before the marker is updated,\n   * event if it does not mean that the event will be ready.\n   *\n   * Override it if you want to add more functionalities.\n   * It should set the this._active to true and do nothing if\n   * this._active is true.\n   */\n  _activate() {\n    if (this._active || !this._map) {\n      return;\n    }\n\n    this._map.locate(this.options.locateOptions);\n    this._map.fire(\"locateactivate\", this);\n    this._active = true;\n\n    // bind event listeners\n    this._map.on(\"locationfound\", this._onLocationFound, this);\n    this._map.on(\"locationerror\", this._onLocationError, this);\n    this._map.on(\"dragstart\", this._onDrag, this);\n    this._map.on(\"zoomstart\", this._onZoom, this);\n    this._map.on(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      const oriAbs = \"ondeviceorientationabsolute\" in window;\n      if (oriAbs || \"ondeviceorientation\" in window) {\n        const _this = this;\n        const deviceorientation = function () {\n          DomEvent.on(window, oriAbs ? \"deviceorientationabsolute\" : \"deviceorientation\", _this._onDeviceOrientation, _this);\n        };\n        if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === \"function\") {\n          DeviceOrientationEvent.requestPermission().then(function (permissionState) {\n            if (permissionState === \"granted\") {\n              deviceorientation();\n            }\n          });\n        } else {\n          deviceorientation();\n        }\n      }\n    }\n  },\n\n  /**\n   * Called to stop the location engine.\n   *\n   * Override it to shutdown any functionalities you added on start.\n   */\n  _deactivate() {\n    if (!this._active || !this._map) {\n      return;\n    }\n\n    this._map.stopLocate();\n    this._map.fire(\"locatedeactivate\", this);\n    this._active = false;\n\n    if (!this.options.cacheLocation) {\n      this._event = undefined;\n    }\n\n    // unbind event listeners\n    this._map.off(\"locationfound\", this._onLocationFound, this);\n    this._map.off(\"locationerror\", this._onLocationError, this);\n    this._map.off(\"dragstart\", this._onDrag, this);\n    this._map.off(\"zoomstart\", this._onZoom, this);\n    this._map.off(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      this._compassHeading = null;\n      if (\"ondeviceorientationabsolute\" in window) {\n        DomEvent.off(window, \"deviceorientationabsolute\", this._onDeviceOrientation, this);\n      } else if (\"ondeviceorientation\" in window) {\n        DomEvent.off(window, \"deviceorientation\", this._onDeviceOrientation, this);\n      }\n    }\n  },\n\n  /**\n   * Check if the current zoom level should be kept based on keepCurrentZoomLevel option.\n   * @returns {boolean} true if zoom should be kept, false otherwise\n   */\n  _shouldKeepCurrentZoom() {\n    const option = this.options.keepCurrentZoomLevel;\n\n    // If option is an array [minZoom, maxZoom], check if current zoom is within range\n    if (Array.isArray(option) && option.length === 2) {\n      const currentZoom = this._map.getZoom();\n      const [minZoom, maxZoom] = option;\n      return currentZoom >= minZoom && currentZoom <= maxZoom;\n    }\n\n    // Only return true if explicitly set to true\n    return option === true;\n  },\n\n  /**\n   * Pan and/or zoom the map to the current location.\n   * Respects keepCurrentZoomLevel and initialZoomLevel options.\n   */\n  setView() {\n    this._drawMarker();\n    if (this._isOutsideMapBounds()) {\n      this._event = undefined; // clear the current location so we can get back into the bounds\n      this.options.onLocationOutsideMapBounds(this);\n      return;\n    }\n\n    const { latlng } = this._event;\n    const fly = this.options.flyTo;\n    let method, args;\n\n    if (this._justClicked && this.options.initialZoomLevel !== false) {\n      method = fly ? \"flyTo\" : \"setView\";\n      args = [latlng, this.options.initialZoomLevel];\n    } else if (this._shouldKeepCurrentZoom()) {\n      method = fly ? \"flyTo\" : \"panTo\";\n      args = [latlng];\n    } else {\n      method = fly ? \"flyToBounds\" : \"fitBounds\";\n      args = [\n        this.options.getLocationBounds(this._event),\n        {\n          padding: this.options.circlePadding,\n          maxZoom: this.options.locateOptions.maxZoom\n        }\n      ];\n    }\n\n    this._setViewIgnoringEvents(method, args);\n  },\n\n  /**\n   * Execute a map view method while ignoring zoom/pan events to prevent breaking following mode.\n   * @param {string} method - The map method name to call ('flyTo', 'setView', 'panTo', 'fitBounds', 'flyToBounds')\n   * @param {Array} args - Arguments to pass to the method\n   */\n  _setViewIgnoringEvents(method, args) {\n    this._ignoreEvent = true;\n    this._map[method](...args);\n    requestAnimationFrame(() => {\n      // Wait until after the next animFrame because flyTo/flyToBounds can be async\n      this._ignoreEvent = false;\n    });\n  },\n\n  /**\n   *\n   */\n  _drawCompass() {\n    if (!this._event) {\n      return;\n    }\n\n    const latlng = this._event.latlng;\n\n    if (this.options.showCompass && latlng && this._compassHeading !== null) {\n      const cStyle = this._isFollowing() ? this.options.followCompassStyle : this.options.compassStyle;\n      if (!this._compass) {\n        this._compass = new this.options.compassClass(latlng, this._compassHeading, cStyle).addTo(this._layer);\n      } else {\n        this._compass.setLatLng(latlng);\n        this._compass.setHeading(this._compassHeading);\n        // If the compassClass can be updated with setStyle, update it.\n        if (this._compass.setStyle) {\n          this._compass.setStyle(cStyle);\n        }\n      }\n      //\n    }\n    if (this._compass && (!this.options.showCompass || this._compassHeading === null)) {\n      this._compass.removeFrom(this._layer);\n      this._compass = null;\n    }\n  },\n\n  /**\n   * Draw the marker and accuracy circle on the map.\n   *\n   * Uses the event retrieved from onLocationFound from the map.\n   */\n  _drawMarker() {\n    if (!this._event) {\n      return;\n    }\n\n    const latlng = this._event.latlng;\n    const accuracy = this._event.accuracy ?? 0;\n    const isFollowing = this._isFollowing();\n\n    // Draw accuracy circle\n    if (this.options.drawCircle) {\n      const style = isFollowing ? this.options.followCircleStyle : this.options.circleStyle;\n\n      if (this._circle) {\n        this._circle.setLatLng(latlng).setRadius(accuracy).setStyle(style);\n      } else {\n        const options = Object.assign({}, style, { radius: accuracy });\n        this._circle = new Circle(latlng, options).addTo(this._layer);\n      }\n    }\n\n    // Draw location marker\n    if (this.options.drawMarker) {\n      const style = isFollowing ? this.options.followMarkerStyle : this.options.markerStyle;\n\n      if (this._marker) {\n        this._marker.setLatLng(latlng);\n        if (this._marker.setStyle) {\n          this._marker.setStyle(style);\n        }\n      } else {\n        this._marker = new this.options.markerClass(latlng, style).addTo(this._layer);\n      }\n    }\n\n    // Draw compass\n    this._drawCompass();\n\n    // Bind popup to marker and compass\n    this._bindPopup(latlng, accuracy);\n  },\n\n  /**\n   * Bind popup with location information to marker and compass.\n   * @param {L.LatLng} latlng - The location to bind the popup to.\n   * @param {number} accuracy - The accuracy radius in meters.\n   */\n  _bindPopup(latlng, accuracy) {\n    const t = this.options.strings.popup;\n    if (!this.options.showPopup || !t) {\n      return;\n    }\n\n    // Format distance for display\n    let distance;\n    let unit;\n    let altitude;\n    if (this.options.metric) {\n      distance = accuracy.toFixed(0);\n      unit = this.options.strings.metersUnit;\n      altitude = this._event?.altitude != null ? this._event.altitude.toFixed(1) : \"N/A\";\n    } else {\n      distance = (accuracy * METERS_TO_FEET).toFixed(0);\n      unit = this.options.strings.feetUnit;\n      altitude = this._event?.altitude != null ? (this._event.altitude * METERS_TO_FEET).toFixed(1) : \"N/A\";\n    }\n\n    // Collect template data\n    const data = {\n      distance,\n      unit,\n      lat: latlng.lat.toFixed(6),\n      lng: latlng.lng.toFixed(6),\n      altitude\n    };\n\n    // Generate popup text\n    let popupText;\n    if (typeof t === \"string\") {\n      popupText = LeafletUtil.template(t, data);\n    } else if (typeof t === \"function\") {\n      popupText = t(data);\n    } else {\n      popupText = t;\n    }\n\n    // Bind to marker and compass\n    if (this._marker) {\n      this._marker.bindPopup(popupText)._popup.setLatLng(latlng);\n    }\n    if (this._compass) {\n      this._compass.bindPopup(popupText)._popup.setLatLng(latlng);\n    }\n  },\n\n  /**\n   * Remove the marker from map.\n   */\n  _removeMarker() {\n    this._layer.clearLayers();\n    this._marker = undefined;\n    this._circle = undefined;\n    this._compass = undefined;\n  },\n\n  /**\n   * Unload the plugin and all event listeners.\n   * Kind of the opposite of onAdd.\n   */\n  _unload() {\n    this.stop();\n    // May become undefined during HMR\n    if (this._map) {\n      this._map.off(\"unload\", this._unload, this);\n    }\n  },\n\n  /**\n   * Sets the compass heading\n   */\n  _setCompassHeading(angle) {\n    if (Number.isFinite(angle)) {\n      this._compassHeading = Math.round(angle);\n      requestAnimationFrame(() => this._drawCompass());\n    } else {\n      this._compassHeading = null;\n      this._drawCompass();\n    }\n  },\n\n  /**\n   * If the compass fails calibration just fail safely and remove the compass\n   */\n  _onCompassNeedsCalibration() {\n    this._setCompassHeading();\n  },\n\n  /**\n   * Process and normalise compass events\n   */\n  _onDeviceOrientation(e) {\n    if (!this._active) {\n      return;\n    }\n\n    if (e.webkitCompassHeading) {\n      // iOS\n      this._setCompassHeading(e.webkitCompassHeading);\n    } else if (e.absolute && e.alpha) {\n      // Android\n      this._setCompassHeading(360 - e.alpha);\n    }\n  },\n\n  /**\n   * Calls deactivate and dispatches an error.\n   */\n  _onLocationError(err) {\n    // Handle timeout errors in watch mode differently\n    if (err.code === 3 && this.options.locateOptions.watch) {\n      this._timeoutCount = (this._timeoutCount || 0) + 1;\n\n      // Fire event for developers to handle timeouts\n      this._map.fire(\"locationtimeout\", {\n        error: err,\n        control: this,\n        count: this._timeoutCount\n      });\n\n      // Visual feedback after repeated timeouts\n      if (this._timeoutCount >= 3 && this._container) {\n        addClasses(this._container, \"locate-timeout\");\n      }\n\n      return;\n    }\n\n    // Reset timeout counter for other errors\n    this._timeoutCount = 0;\n    this.stop();\n    this.options.onLocationError(err, this);\n  },\n\n  /**\n   * Stores the received event and updates the marker.\n   */\n  _onLocationFound(e) {\n    // no need to do anything if the location has not changed\n    if (this._event?.latlng?.lat === e.latlng.lat && this._event?.latlng?.lng === e.latlng.lng && this._event?.accuracy === e.accuracy) {\n      return;\n    }\n\n    if (!this._active) {\n      // we may have a stray event\n      return;\n    }\n\n    // Reset timeout counter on successful location\n    this._timeoutCount = 0;\n    if (this._container) {\n      removeClasses(this._container, \"locate-timeout\");\n    }\n\n    this._event = e;\n\n    this._drawMarker();\n    this._updateContainerStyle();\n\n    // Fire event with location data and control reference\n    this._map.fire(\"locatelocationfound\", {\n      ...e,\n      control: this\n    });\n\n    switch (this.options.setView) {\n      case \"once\":\n        if (this._justClicked) {\n          this.setView();\n        }\n        break;\n      case \"untilPan\":\n        if (!this._userPanned) {\n          this.setView();\n        }\n        break;\n      case \"untilPanOrZoom\":\n        if (!this._userPanned && !this._userZoomed) {\n          this.setView();\n        }\n        break;\n      case \"always\":\n        this.setView();\n        break;\n      case false:\n        // don't set the view\n        break;\n    }\n\n    this._justClicked = false;\n  },\n\n  /**\n   * When the user drags. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onDrag() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userPanned = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n\n  /**\n   * When the user zooms. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onZoom() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userZoomed = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n\n  /**\n   * After a zoom ends update the compass and handle sideways zooms\n   */\n  _onZoomEnd() {\n    if (this._event) {\n      this._drawCompass();\n    }\n\n    if (this._event && !this._ignoreEvent) {\n      // If we have zoomed in and out and ended up sideways treat it as a pan\n      if (this._marker && !this._map.getBounds().pad(-0.3).contains(this._marker.getLatLng())) {\n        this._userPanned = true;\n        this._updateContainerStyle();\n        this._drawMarker();\n      }\n    }\n  },\n\n  /**\n   * Compute whether the map is following the user location with pan and zoom.\n   */\n  _isFollowing() {\n    if (!this._active) {\n      return false;\n    }\n\n    if (this.options.setView === \"always\") {\n      return true;\n    } else if (this.options.setView === \"untilPan\") {\n      return !this._userPanned;\n    } else if (this.options.setView === \"untilPanOrZoom\") {\n      return !this._userPanned && !this._userZoomed;\n    }\n\n    return false;\n  },\n\n  /**\n   * Check if location is in map bounds\n   */\n  _isOutsideMapBounds() {\n    if (this._event === undefined) {\n      return false;\n    }\n    return this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng);\n  },\n\n  /**\n   * Toggles button class between following and active.\n   */\n  _updateContainerStyle() {\n    if (!this._container) {\n      return;\n    }\n\n    if (this._active && !this._event) {\n      // active but don't have a location yet\n      this._setClasses(\"requesting\");\n    } else if (this._isFollowing()) {\n      this._setClasses(\"following\");\n    } else if (this._active) {\n      this._setClasses(\"active\");\n    } else {\n      this._cleanClasses();\n    }\n  },\n\n  /**\n   * Sets the CSS classes for the state.\n   */\n  _setClasses(state) {\n    switch (state) {\n      case \"requesting\":\n        removeClasses(this._container, \"active following\");\n        addClasses(this._container, \"requesting\");\n        removeClasses(this._icon, this.options.icon);\n        addClasses(this._icon, this.options.iconLoading);\n        break;\n\n      case \"active\":\n        removeClasses(this._container, \"requesting following\");\n        addClasses(this._container, \"active\");\n        removeClasses(this._icon, this.options.iconLoading);\n        addClasses(this._icon, this.options.icon);\n        break;\n\n      case \"following\":\n        removeClasses(this._container, \"requesting\");\n        addClasses(this._container, \"active following\");\n        removeClasses(this._icon, this.options.iconLoading);\n        addClasses(this._icon, this.options.icon);\n        break;\n    }\n  },\n\n  /**\n   * Removes all classes from button.\n   */\n  _cleanClasses() {\n    DomUtil.removeClass(this._container, \"requesting\");\n    DomUtil.removeClass(this._container, \"active\");\n    DomUtil.removeClass(this._container, \"following\");\n\n    removeClasses(this._icon, this.options.iconLoading);\n    addClasses(this._icon, this.options.icon);\n  },\n\n  /**\n   * Reinitializes state variables.\n   */\n  _resetVariables() {\n    // whether locate is active or not\n    this._active = false;\n\n    // true if the control was clicked for the first time\n    // we need this so we can pan and zoom once we have the location\n    this._justClicked = false;\n\n    // timeout counter for visual feedback\n    this._timeoutCount = 0;\n\n    // remove timeout styling\n    if (this._container) {\n      removeClasses(this._container, \"locate-timeout\");\n    }\n\n    // true if the user has panned the map after clicking the control\n    this._userPanned = false;\n\n    // true if the user has zoomed the map after clicking the control\n    this._userZoomed = false;\n  }\n});\n\nfunction locate(options) {\n  return new LocateControl(options);\n}\n\nexport { LocationMarker, CompassMarker, LocateControl, locate };\n"],"names":["METERS_TO_FEET","addClasses","el","names","split","forEach","className","classList","add","removeClasses","remove","LocationMarker","Marker","extend","initialize","latlng","options","setOptions","this","_latlng","createIcon","opt","style","color","weight","fillColor","fillOpacity","opacity","filter","v","undefined","map","k","join","icon","_getIconSVG","_locationIcon","divIcon","html","svg","iconSize","w","h","setIcon","r","radius","s","s2","setStyle","CompassMarker","heading","_heading","setHeading","depth","_arrowPoints","width","Math","PI","ux","cos","uy","sin","vx","vy","Cx","Cy","LocateControl","Control","position","layer","setView","keepCurrentZoomLevel","initialZoomLevel","getLocationBounds","locationEvent","bounds","flyTo","clickBehavior","inView","outOfView","inViewNotFollowing","returnToPrevBounds","cacheLocation","drawCircle","drawMarker","showCompass","markerClass","compassClass","circleStyle","markerStyle","compassStyle","followCircleStyle","followMarkerStyle","followCompassStyle","iconLoading","iconElementTag","textElementTag","circlePadding","metric","createButtonCallback","container","link","DomUtil","create","title","strings","href","setAttribute","text","textContent","parentNode","display","onLocationError","err","alert","message","onLocationOutsideMapBounds","control","stop","outsideMapBoundsMsg","showPopup","metersUnit","feetUnit","popup","locateOptions","maxZoom","Infinity","watch","cloned","key","val","Array","isArray","constructor","Object","cloneOptions","userVal","defaultVal","assign","onAdd","_container","_map","_layer","LayerGroup","addTo","_event","_compassHeading","_prevBounds","linkAndIcon","_link","_icon","DomEvent","on","ev","stopPropagation","preventDefault","_onClick","_resetVariables","_unload","onRemove","_justClicked","wasFollowing","_isFollowing","_userPanned","_userZoomed","_active","behaviors","behavior","getBounds","contains","flyToBounds","fitBounds","bind","f","start","_updateContainerStyle","_activate","_drawMarker","_deactivate","_cleanClasses","_removeMarker","stopFollowing","locate","fire","_onLocationFound","_onLocationError","_onDrag","_onZoom","_onZoomEnd","oriAbs","window","_this","deviceorientation","_onDeviceOrientation","DeviceOrientationEvent","requestPermission","then","permissionState","stopLocate","off","_shouldKeepCurrentZoom","option","length","currentZoom","getZoom","minZoom","_isOutsideMapBounds","fly","method","args","padding","_setViewIgnoringEvents","_ignoreEvent","requestAnimationFrame","_drawCompass","cStyle","_compass","setLatLng","removeFrom","accuracy","isFollowing","_circle","setRadius","Circle","_marker","_bindPopup","t","distance","unit","altitude","toFixed","data","lat","lng","popupText","LeafletUtil","template","bindPopup","_popup","clearLayers","_setCompassHeading","angle","Number","isFinite","round","_onCompassNeedsCalibration","e","webkitCompassHeading","absolute","alpha","code","_timeoutCount","error","count","pad","getLatLng","maxBounds","_setClasses","state","removeClass"],"mappings":"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"}